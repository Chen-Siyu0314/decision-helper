# decision-helper.pyï¼ˆæœ€çµ‚å‡ç´šæ•´åˆç‰ˆ + å¤šæƒ…å¢ƒæ¨è–¦ç”¢ç”Ÿå™¨ + UX å¼·åŒ–ï¼‰by æ€å®‡
#.\.venv\Scripts\activate
#streamlit run operation/decision-helper.py

import streamlit as st
import random
import json
import os
from collections import Counter
import matplotlib.pyplot as plt
from gtts import gTTS
from io import BytesIO

def play_tts(text):
    tts = gTTS(text=text, lang="zh-tw")
    mp3_fp = BytesIO()
    tts.write_to_fp(mp3_fp)
    st.audio(mp3_fp.getvalue(), format="audio/mp3")

st.set_page_config(page_title="é¸æ“‡å›°é›£æ•‘æ˜Ÿ", page_icon="ğŸ¯", layout="centered")
# é¡¯ç¤ºåœ–ç‰‡
st.image("operation/cute_decision_image.png", caption="é¸æ“‡å›°é›£ç—‡æ—¥å¸¸", use_container_width=True)

# ========== åå¥½è¨˜éŒ„åˆå§‹åŒ– ========== #
log_file = "choice_log.json"
if not os.path.exists(log_file):
    with open(log_file, "w", encoding="utf-8") as f:
        json.dump({}, f, indent=2)

with open(log_file, "r", encoding="utf-8") as f:
    history_preferences = json.load(f)

# ========== é—œéµå­—å°ç…§è¡¨ ========== #
mood_keywords = {
    "ä¸‹é›¨": ["å®¤å…§", "é¿é›¨", "ä¸æ¿•"],
    "æ‡¶": ["å¤–é€", "å…å‡ºé–€", "çœåŠ›"],
    "æƒ³æ”¾é¬†": ["æ³¡æ¹¯", "æŒ‰æ‘©", "éœ"],
    "å£“åŠ›å¤§": ["å¥èº«", "è·‘æ­¥", "æ•£æ­¥"],
    "å­¤å–®": ["æœ‹å‹", "ç¤¾äº¤"]
}

purpose_keywords = {
    "å­¸ç¿’ ğŸ“š": ["åœ–æ›¸é¤¨", "é–±è®€", "è‡ªä¿®", "å’–å•¡å»³"],
    "åƒæ±è¥¿ ğŸ½": ["ç«é‹", "é¤å»³", "å¤–é€", "ç”œé»"],
    "æ”¾é¬† ğŸ§˜": ["æ³¡æ¹¯", "èººè‘—", "éœ"],
    "è³¼ç‰© ğŸ›": ["ç™¾è²¨", "é€›è¡—"],
    "ç´„æœƒ â¤ï¸": ["æ™¯é»", "å¤œæ™¯", "æµªæ¼«"],
    "é‹å‹• ğŸƒ": ["è·‘æ­¥", "å¥èº«", "æ‰“çƒ"],
    "ç¤¾äº¤ ğŸ—£": ["æœ‹å‹", "èšæœƒ", "èŠå¤©"],
    "æ‰“ç™¼æ™‚é–“ â³": ["YouTube", "é–’æ™ƒ", "éŠæˆ²"],
    "çœ‹é›»å½± ğŸ“½": ["é›»å½±é™¢", "å½±åŸ", "æ²™ç™¼"],
    "ç©éŠæˆ² ğŸ®": ["LOL", "Switch", "é›»ç©"]
}

# ========== è©³ç´°æ¨è–¦ç†ç”±è³‡æ–™åº«ï¼ˆå¤šæƒ…å¢ƒï¼‰ ========== #
detail_reasons = {
    "åœ–æ›¸é¤¨": "é©åˆéœ€è¦é›†ä¸­ç²¾ç¥æº–å‚™è€ƒè©¦ï¼Œå®‰éœã€å„€å¼æ„Ÿå¼·ã€‚",
    "å’–å•¡å»³": "æœ‰æ°›åœï¼Œé©åˆè¼•é¬†å­¸ç¿’æˆ–æ”¾é¬†ï¼Œä½†æœ‰æ™‚è¼ƒåµé›œã€‚",
    "å®¶è£¡": "æ–¹ä¾¿ä½†å®¹æ˜“åˆ†å¿ƒï¼Œç¼ºä¹æ˜ç¢ºç•Œç·šèˆ‡å„€å¼æ„Ÿã€‚",
    "æ³¡æ¹¯": "å¹«åŠ©èˆ’å£“ã€æ”¾é¬†èº«å¿ƒï¼Œé©åˆå£“åŠ›å¤§æˆ–å¤©æ°£å†·çš„æ™‚å€™ã€‚",
    "è·‘æ­¥": "ç°¡å–®åŸ·è¡Œçš„é‹å‹•æ–¹å¼ï¼Œæœ‰åŠ©æƒ…ç·’é‡‹æ”¾ï¼Œä½†éœ€æ³¨æ„å¤©æ°£ã€‚",
    "æ‰“çƒ": "ç¤¾äº¤å‹é‹å‹•ï¼Œèƒ½å¢é€²äº’å‹•ï¼Œä½†éœ€ä»–äººé…åˆã€‚",
    "å¥èº«": "è‡ªä¸»èª¿æ•´å¼·åº¦ï¼Œæœ‰æ•ˆç‡æ’è§£å£“åŠ›ã€‚",
    "æœ‹å‹èšæœƒ": "é©åˆç¤¾äº¤éœ€æ±‚ï¼Œä½†è‹¥ä¸æƒ³äº’å‹•æœƒé€ æˆå£“åŠ›ã€‚",
    "å¤–é€": "å¿«é€Ÿã€çœåŠ›ï¼Œé©åˆæ‡¶æƒ°æˆ–ä¸æƒ³å‡ºé–€çš„ç‹€æ…‹ã€‚",
    "ç™¾è²¨å…¬å¸": "é€›è¡—è³¼ç‰©ã€æ‰“ç™¼æ™‚é–“ï¼Œé©åˆæƒ³åˆºæ¿€ä¸€ä¸‹çš„äººã€‚",
    "å¤œæ™¯": "æµªæ¼«é©åˆç´„æœƒï¼Œæå‡æ°›åœä½†éœ€å¤–å‡ºèˆ‡å®‰æ’ã€‚",
    "é›»å½±é™¢": "æ²‰æµ¸å¼æ”¾é¬†æ–¹å¼ï¼Œé©åˆæƒ³è½‰æ›æƒ…ç·’ã€ç„¡äººæ‰“æ“¾ã€‚",
    "å”±æ­Œ": "é©åˆå®£æ´©æƒ…ç·’ã€åœ˜é«”æ´»å‹•ï¼Œä½†éŸ³é‡å¤§ä¸é©åˆéœæ…‹ç‹€æ…‹ã€‚",
    "è½éŸ³æ¨‚": "å¯å–®ç¨é€²è¡Œï¼Œèª¿ç¯€æƒ…ç·’ï¼Œè¼•é¬†è‡ªåœ¨ç„¡å£“åŠ›ã€‚",
    "çœ‹æ›¸": "é©åˆå®‰éœæ™‚å…‰ï¼Œè‡ªæˆ‘å……å¯¦ã€æ·±åº¦æ”¾é¬†ã€‚",
    "å†¥æƒ³": "é‡è¦–å…§åœ¨å¹³éœï¼Œå¹«åŠ©ç¡çœ èˆ‡æƒ…ç·’èª¿ç¯€ã€‚",
    "æ‰“æƒæˆ¿é–“": "è½‰ç§»æ³¨æ„åŠ›ä¸¦å‰µé€ æ•´æ½”ç’°å¢ƒï¼Œé©åˆç„¦èºæ™‚ã€‚",
    "æ»‘æ‰‹æ©Ÿ": "å¿«é€Ÿæ‰“ç™¼æ™‚é–“ï¼Œä½†é•·æ™‚é–“å¯èƒ½æ„Ÿåˆ°ç©ºè™›ã€‚",
    "çœ‹Netflix": "è¦–è¦ºæ”¾é¬†ã€åŠ‡æƒ…æ²‰æµ¸ï¼Œé©åˆç–²ç´¯æƒ³æ”¾ç©ºæ™‚ã€‚",
    "çœ‹YouTube": "è¼•é¬†ã€è‡ªç”±åˆ‡æ›å…§å®¹ï¼Œé©åˆé›¶ç¢æ™‚é–“æ”¾é¬†ã€‚",
    "è³¼ç‰©ç¶²ç«™": "é€›ç¶²æ‹è½‰æ›æƒ…ç·’ï¼Œéœ€æ§åˆ¶è¡å‹•é¿å…å¾Œæ‚”ã€‚",
    "å¯«æ—¥è¨˜": "å…§åœ¨æ•´ç†è‡ªæˆ‘ï¼Œé©åˆå£“åŠ›æˆ–æƒ…ç·’ä½è½æ™‚ã€‚",
    "ç•«ç•«": "å‰µæ„é‡‹æ”¾ï¼Œé©åˆæƒ…ç·’ç´¯ç©ã€éœ€è¦å‡ºå£æ™‚ã€‚",
    "æ‰‹ä½œDIY": "å°ˆæ³¨æ²»ç™’ç³»æ´»å‹•ï¼Œæ…¢ç¯€å¥æ”¾é¬†å¿ƒæƒ…ã€‚",
    "åšç”œé»": "éç¨‹æœ‰æˆå°±æ„Ÿï¼Œé©åˆç™‚ç™’è‡ªå·±ä¹Ÿèƒ½åˆ†äº«ã€‚",
    "çœ‹å±•è¦½": "æ–‡é’æ”¾é¬†æ–¹å¼ï¼Œé©åˆç¨è™•æˆ–éœæ…‹ç¤¾äº¤ã€‚",
    "å»å¤œå¸‚": "ç†±é¬§æœ‰åƒæœ‰é€›ï¼Œé©åˆæ‰“ç™¼æ™‚é–“æˆ–æœ‹å‹èšæœƒã€‚",
    "æ¡ŒéŠ": "å¤šäººäº’å‹•ã€å»ºç«‹é€£çµï¼Œé©åˆæœ‹å‹èšæœƒä½†éœ€äººå¤šã€‚",
    "é‡é¤": "èˆ‡è‡ªç„¶æ¥è§¸çš„è¼•ç¤¾äº¤ï¼Œé©åˆå¤©æ°£å¥½ã€æœ‰ç©ºé–’æ™‚ã€‚",
    "æ‰“å·¥": "è½‰æ›ç’°å¢ƒã€æœ‰æ”¶å…¥æ„Ÿï¼Œé©åˆæƒ³è®“è‡ªå·±æ›´æœ‰æŒæ§æ„Ÿæ™‚ã€‚",
    "é¢è©¦æº–å‚™": "æå‡è‡ªä¿¡ï¼Œå¼·è¿«è‡ªå·±èšç„¦ç›®æ¨™å°å‘ã€‚",
    "å¯«ä¼åŠƒ": "éœ€è¦é›†ä¸­èˆ‡å‹•è…¦ï¼Œé©åˆæ—©ä¸Šæˆ–èƒ½é‡é«˜æ™‚ã€‚",
    "å ±åèª²ç¨‹": "çµ¦è‡ªå·±æ˜ç¢ºç›®æ¨™èˆ‡å­¸ç¿’ç¯€å¥ï¼Œé¿å…èŒ«ç„¶ã€‚",
    "ç™¼å‘†": "ä»€éº¼éƒ½ä¸åšä¹Ÿå¾ˆå¥½ï¼Œçµ¦è‡ªå·±å®Œå…¨æ”¾ç©ºçš„æ™‚é–“ã€‚",
    "çœ‹æ—¥å‡º": "ç™‚ç™’åˆæœ‰å„€å¼æ„Ÿï¼Œé©åˆé‡æ–°å‡ºç™¼æˆ–ä½è½æ™‚ã€‚",
    "é€›èª å“": "äººæ–‡ç©ºé–“å®‰éœï¼Œé©åˆæ”¾é¬†èˆ‡éˆæ„Ÿåˆºæ¿€ã€‚",
    "ä¸‹æ£‹": "å‹•è…¦éœæ…‹äº’å‹•ï¼Œé©åˆå®…åœ¨å®¶åˆä¸æƒ³æ»‘æ‰‹æ©Ÿæ™‚ã€‚",
    "ä¿®åœ–": "å‰µæ„è¼¸å‡ºèˆ‡å°ˆæ³¨çµåˆï¼Œé©åˆæ™šä¸Šçš„éœæ…‹æ™‚é–“ã€‚",
    "ç·¨è¼¯å½±ç‰‡": "é«˜é›†ä¸­åŠ›ï¼Œé©åˆå…¨èº«å¿ƒæŠ•å…¥æƒ³å¿˜è¨˜ç…©æƒ±æ™‚ã€‚",
    "é€›æ¤ç‰©åœ’": "è¦ªè¿‘è‡ªç„¶ã€æœ‰åŠ©ç·©è§£ç„¦èºã€‚",
    "é€›è¶…å¸‚": "å°æ¡è²·å¯å¸¶ä¾†æ§åˆ¶æ„Ÿèˆ‡ç”Ÿæ´»å„€å¼æ„Ÿã€‚",
    "çœ‹å¡é€š": "å›åˆ°ç«¥å¿ƒã€æ”¾ä¸‹å£“åŠ›ã€é©åˆå¿ƒç´¯ä½†åˆä¸æƒ³ç©ºç™½æ™‚ã€‚",
    "å¯«ä¿¡": "å°è‡ªå·±æˆ–ä»–äººæŠ’ç™¼ï¼Œæ–‡å­—ç™‚ç™’æ„Ÿåè¶³ã€‚",
    "æ³¡è…³": "å±…å®¶èˆ’å£“å¦™æ‹›ï¼Œå¹«åŠ©èº«å¿ƒæ”¾é¬†èˆ‡ç¡çœ ã€‚",
    "çœ‹è€ç…§ç‰‡": "æ‡·èˆŠå¸¶ä¾†æº«æš–å›æ†¶ï¼Œé©åˆå…§åœ¨ç–²æ†Šæ™‚ã€‚",
    "åšèœ": "å‹•æ‰‹åˆå‹•è…¦ï¼Œé©åˆæƒ…ç·’æ³¢å‹•å¤§æˆ–æƒ³æŒæ§ç”Ÿæ´»ç¯€å¥æ™‚ã€‚",
    "æ›¬å¤ªé™½": "è£œå……èƒ½é‡ã€æå‡å¿ƒæƒ…ï¼Œç°¡å–®æœ‰æ•ˆçš„è‡ªç„¶ç™‚ç™’ã€‚",
    "ç©æ‰‹éŠ": "å¯å¿«å¯æ…¢ã€ç¯€å¥è‡ªç”±ï¼Œé©åˆç‰‡åˆ»é€ƒé¿ã€‚",
    "èººåºŠè€å»¢": "å®Œå…¨æ”¾ç©ºã€æš«æ™‚å°æŠ—å£“åŠ›æ„Ÿï¼Œé©åˆæ¥µåº¦æ‡¶æˆ–ä½æ½®æœŸã€‚",
    "å»èª å“æ™ƒæ™ƒ": "çµåˆäººæ–‡æ›¸é¦™èˆ‡ç©ºé–“æ”¾é¬†ï¼Œé©åˆä½å£“ç‹€æ…‹æ¢å¾©ã€‚",
    "æ‰¾äººèŠå¤©": "äººéš›é™ªä¼´èˆ’ç·©å£“åŠ›ï¼Œé©åˆå­¤å–®æˆ–å¿ƒäº‹å£“æŠ‘æ™‚ã€‚",
    "èƒŒè‹±æ–‡å–®å­—": "çŸ­æœŸå¼·åˆ¶é›†ä¸­ï¼Œæœ‰ç›®æ¨™çš„å°æŒ‘æˆ°ï¼Œé©åˆç©ºè™›æ™‚è½‰ç§»æ³¨æ„ã€‚"
}

# ========== æ ¸å¿ƒåˆ†æ ========== #
def analyze_choices(options, mood, purpose, reason_text):
    scores = {}
    details = {}
    filtered_options = []

    for option in options:
        if "ä¸‹é›¨" in mood and any(word in option for word in ["è·‘æ­¥", "ç™»å±±", "éœ²ç‡Ÿ"]):
            continue
        if "ä¸æƒ³ç¤¾äº¤" in reason_text and any(word in option for word in ["èšæœƒ", "æœ‹å‹", "è¯èª¼"]):
            continue

        base = history_preferences.get(option, 3)
        mood_bonus = sum(1 for k in mood_keywords if k in mood and any(word in option for word in mood_keywords[k]))
        purpose_bonus = sum(1 for word in purpose_keywords.get(purpose, []) if word in option)
        reason_bonus = sum(1 for word in reason_text.split() if word in option)
        total = base + mood_bonus + purpose_bonus + reason_bonus + random.uniform(-0.5, 0.5)

        scores[option] = total
        details[option] = {
            "base": base,
            "mood_bonus": mood_bonus,
            "purpose_bonus": purpose_bonus,
            "reason_bonus": reason_bonus
        }
        filtered_options.append(option)

    best = max(scores, key=scores.get) if scores else "ï¼ˆç„¡æ¨è–¦ï¼‰"
    return best, scores, details, filtered_options

# ========== å„²å­˜ç´€éŒ„ ========== #
def update_history(choice):
    history_preferences[choice] = history_preferences.get(choice, 0) + 1
    with open(log_file, "w", encoding="utf-8") as f:
        json.dump(history_preferences, f, indent=2, ensure_ascii=False)

# ========== UIä»‹é¢é–‹å§‹ ========== #
st.title("ğŸ¯ é¸æ“‡å›°é›£æ•‘æ˜Ÿ")

purpose = st.selectbox("ä½ çš„ä¸»è¦ç›®çš„ï¼š", list(purpose_keywords.keys()))
mood = st.text_input("ä½ ç¾åœ¨çš„å¿ƒæƒ…æ˜¯ï¼Ÿ")
reason = st.text_area("åšé€™å€‹é¸æ“‡çš„èƒŒæ™¯ / åŸå› ")
options_input = st.text_area("è«‹è¼¸å…¥é¸é …ï¼ˆç”¨é€—è™Ÿåˆ†éš”ï¼‰ï¼š", placeholder="å¦‚ï¼šè·‘æ­¥, æ³¡æ¹¯, æ‰“é›»å‹•")

if st.button("å¹«æˆ‘é¸ï¼"):
    options = [opt.strip() for opt in options_input.split(",") if opt.strip()]
    if not options:
        st.warning("è«‹è¼¸å…¥è‡³å°‘ä¸€å€‹é¸é …")
    else:
        choice, scores, details, filtered = analyze_choices(options, mood, purpose, reason)
        if choice != "ï¼ˆç„¡æ¨è–¦ï¼‰":
            update_history(choice)
            st.success(f"âœ… æ¨è–¦ä½ é¸æ“‡ï¼š**{choice}**")
            tts_text = f"æ¨è–¦ä½ é¸æ“‡ {choice}ï¼Œå› ç‚ºï¼š{detail_reasons.get(choice, 'é€™é …é¸æ“‡æœ€é©åˆä½ ç›®å‰çš„æƒ…å¢ƒã€‚')}"
            play_tts(tts_text)

            # ========== å‡ç´šæ¨è–¦èªªæ˜å€ ========== #
            st.markdown("---")
            st.markdown("### ğŸ§  æ¨è–¦åŸå› ")

            st.markdown(f"ä½ æåˆ°ã€Œ**{reason}**ã€ï¼Œç•¶ä¸‹å¿ƒæƒ…æ˜¯ã€Œ**{mood}**ã€ï¼Œç›®çš„æ˜¯ã€Œ**{purpose}**ã€ã€‚\n\n")

            st.markdown("æˆ‘å€‘æ ¹æ“šä½ çš„éœ€æ±‚åˆ†æå„é¸é …å¦‚ä¸‹ï¼š")
            for opt in filtered:
                line = f"ğŸ”¹ **{opt}**ï¼š{detail_reasons.get(opt, 'æ­¤é¸é …ç›¸é—œç¨‹åº¦ä¸­ç­‰ï¼Œä¾æƒ…æ³å¯è€ƒæ…®ã€‚')}"
                if opt == choice:
                    st.markdown(f"âœ… {line} **â†’ æœ€æ¨è–¦**")
                else:
                    st.markdown(f"âŒ {line} **â†’ ä¸æ¨è–¦**")

            st.markdown("\nğŸ§  ç¶œåˆåˆ¤æ–·ï¼Œæˆ‘å€‘èªç‚º **{choice}** æœ€èƒ½å°æ‡‰ä½ ç›®å‰çš„ç‹€æ³èˆ‡éœ€æ±‚ã€‚")

            # ========== æ˜Ÿç­‰è©•æ¯”è¡¨æ ¼ ========== #
            st.markdown("---")
            st.markdown("### ğŸŒŸ å„é¸é …æ¨è–¦ç¨‹åº¦")
            table_data = []
            for opt in filtered:
                score = scores[opt]
                star = "â­ï¸" * int(round(min(score, 5)))
                reason_str = []
                if details[opt]["purpose_bonus"] > 0:
                    reason_str.append("ç¬¦åˆä¸»è¦ç›®çš„")
                if details[opt]["mood_bonus"] > 0:
                    reason_str.append("è²¼è¿‘ä½ ç›®å‰å¿ƒæƒ…")
                if details[opt]["reason_bonus"] > 0:
                    reason_str.append("èˆ‡ä½ çš„æè¿°ç›¸é—œ")
                table_data.append(f"**{opt}** ï½œ {star} ï½œ {', '.join(reason_str) if reason_str else 'é—œè¯è¼ƒå°‘'}")

            for row in table_data:
                st.markdown(row)

# ========== æ­·å²æ¨è–¦ç´€éŒ„åœ–è¡¨ ========== #
if st.checkbox("ğŸ“Š æŸ¥çœ‹æˆ‘æœ€å¸¸è¢«æ¨è–¦çš„é¸é …åœ–è¡¨"):
    if history_preferences:
        st.markdown("### ğŸ” æ­·å²æ¨è–¦æ¬¡æ•¸")
        count = Counter(history_preferences)
        st.bar_chart(count)
    else:
        st.info("ç›®å‰é‚„æ²’æœ‰ç´¯ç©æ¨è–¦ç´€éŒ„å–”ï½")

# ========== UX å›é¥‹äº’å‹• ========== #
st.markdown("---")
st.subheader("ğŸˆ æˆ‘æ¥å—é€™å€‹é¸æ“‡ï¼")

if st.button("âœ… é€™å°±æ˜¯æˆ‘çš„é¸æ“‡ï¼"):
    st.success("å¤ªæ£’äº†ï¼é¸æ“‡ä¸æ˜¯å•é¡Œï¼Œæ˜¯èªè­˜è‡ªå·±çš„é–‹å§‹ï¼âœ¨")
    st.balloons()
    st.markdown("ğŸ“œ **ã€Œæ¯ä¸€æ¬¡æ±ºå®šï¼Œéƒ½æ˜¯æ›´é è¿‘ç›®æ¨™çš„ä¸€æ­¥ã€‚ã€**")
    st.markdown("ğŸ§  **ã€Œä½ ä¸æ˜¯é¸æœ€å°çš„ï¼Œè€Œæ˜¯é¸æœ€é©åˆç•¶ä¸‹çš„è‡ªå·±ã€‚ã€**")

# ========== å‰µæ–°äº’å‹•éŠæˆ² ========== #
st.markdown("---")
st.subheader("ğŸ•¹ï¸ ä½ ä¾†çŒœçŒœæˆ‘æœƒæ¨è–¦ä»€éº¼ï¼Ÿ")

game_options_input = st.text_area("è«‹è¼¸å…¥å¹¾å€‹é¸é …ä¾†è®“æˆ‘é æ¸¬ï¼ˆé€—è™Ÿåˆ†éš”ï¼‰", placeholder="ä¾‹å¦‚ï¼šå’–å•¡å»³, åœ–æ›¸é¤¨, è·‘æ­¥, çœ‹Netflix")
user_guess = st.text_input("ä½ è¦ºå¾—æˆ‘æœƒé¸å“ªä¸€å€‹ï¼Ÿ")

if st.button("ğŸ¯ è®“æˆ‘ä¾†é æ¸¬ï¼"):
    game_opts = [x.strip() for x in game_options_input.split(",") if x.strip()]
    if not game_opts:
        st.warning("è«‹å…ˆè¼¸å…¥é¸é …å–”ï¼")
    else:
        guess_result = random.choice(game_opts)
        st.markdown(f"ğŸ¤– æˆ‘é æ¸¬çš„é¸é …æ˜¯ï¼š**{guess_result}**")
        if user_guess.strip() == guess_result:
            st.success("ğŸ‰ çŒœå°å•¦ï¼æˆ‘å€‘æƒ³çš„ä¸€æ¨£ï¼")
        else:
            st.info("ğŸ™ˆ å¯æƒœçŒœéŒ¯äº†ï¼Œä¸éæ¯å€‹é¸æ“‡éƒ½å€¼å¾—è©¦è©¦ï¼")

st.caption("ğŸ§  by æ€å®‡ï½œå¾ç›®çš„ã€å¿ƒæƒ…èˆ‡èƒŒæ™¯å‡ºç™¼ï¼Œåšå‡ºæœ‰é‚è¼¯çš„æ¨è–¦")
